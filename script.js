// ---------------------
// The First Impression ‚Äî Step 4+ (Clean Full Script)
// Rounds: AGE -> NAME -> SALARY -> OCCUPATION -> STATE
// Faces: Vercel Blob (generated by /admin.html)
// Uniqueness: no face repeats + no exact profile combo repeats (per device)
// ---------------------

const ROUND_ORDER = ["age", "name", "salary", "occupation", "state"];

// Attempt limits
const MAX_AGE_TRIES = 5;
const MAX_NAME_TRIES = 6;
const MAX_SALARY_TRIES = 5;
const MAX_OCC_TRIES = 6;
const MAX_STATE_TRIES = 5;

// Scoring ladder for Name + Occupation (attempt-based)
const LADDER_6 = [10, 10, 8, 6, 4, 2];

// Local storage keys (device-level uniqueness)
const LS_USED_FACES = "tfi_used_faces_v1";
const LS_USED_COMBOS = "tfi_used_combos_v1";

// State list (dropdown ‚Äúmap-style beta‚Äù ‚Äî clickable SVG map comes next)
const STATES = [
  "Alabama","Alaska","Arizona","Arkansas","California","Colorado","Connecticut","Delaware","Florida","Georgia",
  "Hawaii","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts",
  "Michigan","Minnesota","Mississippi","Missouri","Montana","Nebraska","Nevada","New Hampshire","New Jersey",
  "New Mexico","New York","North Carolina","North Dakota","Ohio","Oklahoma","Oregon","Pennsylvania","Rhode Island",
  "South Carolina","South Dakota","Tennessee","Texas","Utah","Vermont","Virginia","Washington","West Virginia",
  "Wisconsin","Wyoming"
];

// --------- Beta profile pools (we'll swap to profiles.json later) ---------
// Keep these realistic-ish for now; we‚Äôll generate 20k later with real distributions.
const NAMES = [
  "Carson","Michael","Ashley","David","Samantha","Emily","James","Matthew","Olivia","Sophia",
  "Daniel","Andrew","Jessica","Amanda","Ryan","Brandon","Lauren","Taylor","Jordan","Kevin"
];

const OCCUPATIONS = [
  "Retail Associate","Accountant","Nurse","Software Engineer","Teacher","Sales Rep","Truck Driver",
  "Electrician","Server","Warehouse Worker","Dental Assistant","Office Manager","Security Guard",
  "Customer Support","Construction Worker","Mechanic","Barber","Real Estate Agent","Cook","HR Specialist"
];

// Simple region-ish clue generator for states (beta)
const STATE_CLUE_BANK = {
  "California": ["West Coast", "Pacific", "High cost of living"],
  "Texas": ["South", "Very large state", "No state income tax"],
  "Florida": ["Southeast", "Warm climate", "Lots of coastline"],
  "Washington": ["Pacific Northwest", "Rainy", "Tech-heavy"],
  "New York": ["Northeast", "Big cities", "High population"],
  "Ohio": ["Midwest", "Great Lakes region", "Four seasons"],
  "Arizona": ["Southwest", "Desert climate", "Hot summers"],
  "Colorado": ["Mountain state", "High elevation", "Outdoor culture"],
  "Illinois": ["Midwest", "Major metro hub", "Great Lakes access"]
};

// Salary ranges (rough beta). Later we‚Äôll model by state+occupation.
function salaryFor(occupation, state) {
  // base bands (very rough)
  let base = 42000;
  if (occupation.includes("Software")) base = 115000;
  else if (occupation.includes("Accountant")) base = 82000;
  else if (occupation.includes("Nurse")) base = 76000;
  else if (occupation.includes("Teacher")) base = 56000;
  else if (occupation.includes("Electrician") || occupation.includes("Mechanic")) base = 62000;
  else if (occupation.includes("Sales")) base = 58000;
  else if (occupation.includes("Truck")) base = 60000;
  else if (occupation.includes("Office")) base = 64000;
  else if (occupation.includes("Warehouse")) base = 48000;
  else if (occupation.includes("Server") || occupation.includes("Cook")) base = 38000;

  // state multiplier (very rough)
  let mult = 1.0;
  if (["California","New York","Washington","Massachusetts","New Jersey","Maryland"].includes(state)) mult = 1.25;
  if (["Texas","Florida","Colorado","Virginia","Illinois"].includes(state)) mult = 1.12;
  if (["Ohio","Missouri","Indiana","Iowa","Kansas","Kentucky","Alabama","Mississippi"].includes(state)) mult = 0.95;

  // random noise
  const noise = 0.88 + Math.random() * 0.28;
  const salary = Math.round((base * mult * noise) / 1000) * 1000;
  return Math.max(25000, Math.min(250000, salary));
}

function randomInt(min, max) {
  return Math.floor(min + Math.random() * (max - min + 1));
}

function pick(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function $(id){ return document.getElementById(id); }

// ---------- UI FX ----------
function pulse(el){
  el.classList.remove("pulse");
  void el.offsetWidth;
  el.classList.add("pulse");
}

function flashFace(){
  const faceWrap = document.querySelector(".face-wrap");
  if (!faceWrap) return;
  faceWrap.classList.remove("flash");
  void faceWrap.offsetWidth;
  faceWrap.classList.add("flash");
}

function floatPoints(text){
  const el = document.createElement("div");
  el.className = "float fb-correct";
  el.textContent = text;
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), 950);
}

function feedback(text, type, doShake=false){
  const fb = $("feedback");
  if (!fb) return;
  fb.className = "feedback anim-pop " + (type || "");

  fb.classList.remove("shake");
  void fb.offsetWidth;
  if(doShake) fb.classList.add("shake");

  fb.textContent = text;
  flashFace();
}

function setReveal(id, value){
  const el = $(id);
  if (el) el.textContent = value;
}

// ---------- Device-level uniqueness stores ----------
function loadSet(key) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return new Set();
    const arr = JSON.parse(raw);
    return new Set(Array.isArray(arr) ? arr : []);
  } catch {
    return new Set();
  }
}

function saveSet(key, set) {
  try {
    localStorage.setItem(key, JSON.stringify(Array.from(set)));
  } catch {}
}

// ---------- Faces (Blob) ----------
let FACE_URLS = [];

async function loadFaceUrls() {
  try {
    const r = await fetch("/api/faces/list");
    const j = await r.json();
    if (j.ok) FACE_URLS = j.urls || [];
  } catch {
    FACE_URLS = [];
  }
}

// Pick an unused face URL (per device). If exhausted, it will reuse (and warn).
function pickUnusedFaceUrl(usedFaces) {
  if (!FACE_URLS.length) return "";

  const candidates = FACE_URLS.filter(u => !usedFaces.has(u));
  if (candidates.length) return candidates[Math.floor(Math.random() * candidates.length)];

  // exhausted
  return FACE_URLS[Math.floor(Math.random() * FACE_URLS.length)];
}

// ---------- Game State ----------
let score = 0;
let roundIndex = 0;

let triesAge = 0;
let triesName = 0;
let triesSalary = 0;
let triesOcc = 0;
let triesState = 0;

let person = null;         // profile data for the current face
let faceUrl = "";          // current face url
let stateClues = [];       // current state's clue list

const usedFaces = loadSet(LS_USED_FACES);
const usedCombos = loadSet(LS_USED_COMBOS);

function updateScore(delta=0){
  score += delta;
  $("score").textContent = String(score);
  if (delta > 0) {
    pulse($("score"));
    floatPoints("+" + delta);
  }
}

// Create a realistic-ish profile and ensure combo uniqueness (device-level)
function generateUniqueProfile() {
  // Try a bunch of times to avoid repeats
  for (let attempt = 0; attempt < 300; attempt++) {
    const state = pick(STATES);
    const occupation = pick(OCCUPATIONS);

    // Age: keep adult-ish for realism
    const age = randomInt(21, 62);

    // Name: we‚Äôll upgrade to birth-year distributions later
    const name = pick(NAMES);

    const salary = salaryFor(occupation, state);

    const comboSig = `${name}|${age}|${salary}|${occupation}|${state}`;
    if (!usedCombos.has(comboSig)) {
      return {
        name, age, salary, occupation, state,
        comboSig
      };
    }
  }

  // If somehow exhausted, allow repeats (shouldn‚Äôt happen in beta)
  const state = pick(STATES);
  const occupation = pick(OCCUPATIONS);
  const age = randomInt(21, 62);
  const name = pick(NAMES);
  const salary = salaryFor(occupation, state);
  return {
    name, age, salary, occupation, state,
    comboSig: `${name}|${age}|${salary}|${occupation}|${state}`
  };
}

function resetTries(){
  triesAge = triesName = triesSalary = triesOcc = triesState = 0;
}

function setFace(url){
  const img = $("face");
  if (!img) return;
  if (!url) {
    img.src = "https://via.placeholder.com/380x380?text=NO+FACES+YET";
    return;
  }
  img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
}

// Start a new ‚Äúperson‚Äù (face + profile). Enforce no face repeat per device.
function startNewPerson() {
  roundIndex = 0;
  resetTries();

  // reset reveal panel
  setReveal("rAge", "???");
  setReveal("rName", "???");
  setReveal("rSalary", "???");
  setReveal("rOcc", "???");
  setReveal("rState", "???");

  faceUrl = pickUnusedFaceUrl(usedFaces);
  setFace(faceUrl);

  person = generateUniqueProfile();

  // Build state clues
  stateClues = (STATE_CLUE_BANK[person.state] || []).slice();
  if (stateClues.length < 3) {
    // fallback generic clues
    const generic = [];
    // simple region hints (very rough)
    const west = ["California","Oregon","Washington","Nevada","Arizona","Utah","Idaho","Colorado","New Mexico","Montana","Wyoming","Alaska","Hawaii"];
    const south = ["Texas","Florida","Georgia","Alabama","Mississippi","Louisiana","Tennessee","South Carolina","North Carolina","Arkansas","Oklahoma","Kentucky","Virginia","West Virginia"];
    const midwest = ["Ohio","Michigan","Indiana","Illinois","Wisconsin","Minnesota","Iowa","Missouri","Kansas","Nebraska","South Dakota","North Dakota"];
    const northeast = ["New York","New Jersey","Pennsylvania","Massachusetts","Connecticut","Rhode Island","Vermont","New Hampshire","Maine","Maryland","Delaware"];

    if (west.includes(person.state)) generic.push("West / Mountain / Pacific side");
    if (south.includes(person.state)) generic.push("Southern U.S.");
    if (midwest.includes(person.state)) generic.push("Midwest U.S.");
    if (northeast.includes(person.state)) generic.push("Northeast U.S.");

    generic.push("Clue unlocks each miss");
    stateClues = generic.slice(0,3);
  }

  feedback("GET READY‚Ä¶", "", false);
  renderRound();
}

// --------- Round Rendering ---------
function renderRound(){
  const area = $("roundArea");
  const round = ROUND_ORDER[roundIndex];

  if (!area) return;

  if (round === "age") {
    area.innerHTML = `
      <h2>AGE ROUND ‚Äî ${triesAge}/${MAX_AGE_TRIES}</h2>
      <div class="controls">
        <input id="ageInput" type="number" placeholder="Enter age" inputmode="numeric" />
        <button id="ageBtn">SUBMIT</button>
      </div>
      <div style="opacity:.90;margin-top:10px;font-size:15px;">Higher/Lower ‚Ä¢ Within 10 = CLOSE</div>
    `;
    $("ageBtn").onclick = onAge;
    $("ageInput").focus();
    $("ageInput").addEventListener("keydown", e => { if (e.key === "Enter") onAge(); });
    return;
  }

  if (round === "name") {
    area.innerHTML = `
      <h2>NAME ROUND ‚Äî ${triesName}/${MAX_NAME_TRIES}</h2>
      <div class="controls">
        <input id="nameInput" type="text" placeholder="Enter first name" autocomplete="off" />
        <button id="nameBtn">SUBMIT</button>
      </div>
      <div style="opacity:.90;margin-top:10px;font-size:15px;">Points: 1‚Äì2=10, 3=8, 4=6, 5=4, 6=2</div>
    `;
    $("nameBtn").onclick = onName;
    $("nameInput").focus();
    $("nameInput").addEventListener("keydown", e => { if (e.key === "Enter") onName(); });
    return;
  }

  if (round === "salary") {
    area.innerHTML = `
      <h2>SALARY ROUND ‚Äî ${triesSalary}/${MAX_SALARY_TRIES}</h2>
      <div class="controls">
        <input id="salaryInput" type="number" placeholder="Enter salary" inputmode="numeric" />
        <button id="salaryBtn">SUBMIT</button>
      </div>
      <div style="opacity:.90;margin-top:10px;font-size:15px;">Higher/Lower ‚Ä¢ Within $10,000 = CLOSE</div>
    `;
    $("salaryBtn").onclick = onSalary;
    $("salaryInput").focus();
    $("salaryInput").addEventListener("keydown", e => { if (e.key === "Enter") onSalary(); });
    return;
  }

  if (round === "occupation") {
    area.innerHTML = `
      <h2>OCCUPATION ROUND ‚Äî ${triesOcc}/${MAX_OCC_TRIES}</h2>
      <div class="controls">
        <input id="occInput" type="text" placeholder="Enter occupation" autocomplete="off" />
        <button id="occBtn">SUBMIT</button>
      </div>
      <div style="opacity:.90;margin-top:10px;font-size:15px;">Points: 1‚Äì2=10, 3=8, 4=6, 5=4, 6=2</div>
    `;
    $("occBtn").onclick = onOcc;
    $("occInput").focus();
    $("occInput").addEventListener("keydown", e => { if (e.key === "Enter") onOcc(); });
    return;
  }

  // State round (beta dropdown + clue unlock)
  area.innerHTML = `
    <h2>STATE ROUND ‚Äî ${triesState}/${MAX_STATE_TRIES}</h2>
    <div class="controls">
      <select id="stateSelect">${STATES.map(s => `<option value="${s}">${s}</option>`).join("")}</select>
      <button id="stateBtn">GUESS STATE</button>
    </div>
    <div id="clues" style="margin-top:12px; opacity:.98; font-size:16px;"></div>
    <div style="opacity:.70;margin-top:10px;font-size:13px;">Clickable US map is next.</div>
  `;
  $("stateBtn").onclick = onState;
  renderClues();
}

function renderClues(){
  const cluesEl = $("clues");
  if (!cluesEl) return;

  const showCount = Math.min(triesState, stateClues.length);
  const list = stateClues.slice(0, showCount);

  cluesEl.innerHTML = list.length
    ? `<b>CLUES:</b> ${list.map(c => `<span style="display:inline-block;margin:5px 7px;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10)">${c}</span>`).join("")}`
    : `<b>CLUES:</b> (miss a guess to unlock)`;
}

function advanceRound(){
  roundIndex++;
  if (roundIndex >= ROUND_ORDER.length) {
    // Mark face + combo used (device-level)
    if (faceUrl) usedFaces.add(faceUrl);
    if (person?.comboSig) usedCombos.add(person.comboSig);
    saveSet(LS_USED_FACES, usedFaces);
    saveSet(LS_USED_COMBOS, usedCombos);

    feedback("ROUND COMPLETE! üî• NEXT FACE‚Ä¶", "fb-correct", false);
    setTimeout(startNewPerson, 1200);
    return;
  }
  renderRound();
}

// --------- Handlers ---------
function onAge(){
  const val = parseInt($("ageInput").value);
  if (Number.isNaN(val)) return;

  triesAge++;

  if (val === person.age) {
    setReveal("rAge", String(person.age));
    updateScore(10);
    feedback("‚úÖ EXACT AGE! LOCKED IN!", "fb-correct", false);
    setTimeout(advanceRound, 950);
    return;
  }

  const diff = Math.abs(val - person.age);
  if (diff <= 10) {
    feedback("üî• CLOSE! " + (val < person.age ? "‚¨ÜÔ∏è HIGHER" : "‚¨áÔ∏è LOWER"), "fb-close", true);
  } else {
    feedback(val < person.age ? "‚¨ÜÔ∏è HIGHER" : "‚¨áÔ∏è LOWER", "fb-wrong", true);
  }

  if (triesAge >= MAX_AGE_TRIES) {
    setReveal("rAge", String(person.age));
    feedback("‚ùå OUT OF GUESSES ‚Äî AGE: " + person.age, "fb-wrong", false);
    setTimeout(advanceRound, 1100);
  } else {
    renderRound();
  }
}

function onName(){
  const guess = $("nameInput").value.trim();
  if (!guess) return;

  triesName++;

  if (guess.toLowerCase() === person.name.toLowerCase()) {
    const points = LADDER_6[triesName - 1] || 0;
    setReveal("rName", person.name);
    updateScore(points);
    feedback("üéâ NAME CORRECT! +" + points, "fb-correct", false);
    setTimeout(advanceRound, 950);
    return;
  }

  const remaining = MAX_NAME_TRIES - triesName;
  if (remaining <= 0) {
    setReveal("rName", person.name);
    feedback("‚ùå FAIL ‚Äî NAME WAS: " + person.name, "fb-wrong", false);
    setTimeout(advanceRound, 1100);
    return;
  }

  feedback("‚ùå WRONG ‚Äî " + remaining + " LEFT", "fb-wrong", true);
  renderRound();
}

function onSalary(){
  const val = parseInt($("salaryInput").value);
  if (Number.isNaN(val)) return;

  triesSalary++;

  if (val === person.salary) {
    setReveal("rSalary", "$" + person.salary.toLocaleString());
    updateScore(10);
    feedback("‚úÖ EXACT SALARY! LOCKED IN!", "fb-correct", false);
    setTimeout(advanceRound, 950);
    return;
  }

  const diff = Math.abs(val - person.salary);
  if (diff <= 10000) {
    feedback("üí∏ CLOSE! " + (val < person.salary ? "‚¨ÜÔ∏è HIGHER" : "‚¨áÔ∏è LOWER"), "fb-close", true);
  } else {
    feedback(val < person.salary ? "‚¨ÜÔ∏è HIGHER" : "‚¨áÔ∏è LOWER", "fb-wrong", true);
  }

  if (triesSalary >= MAX_SALARY_TRIES) {
    setReveal("rSalary", "$" + person.salary.toLocaleString());
    feedback("‚ùå OUT OF GUESSES ‚Äî $" + person.salary.toLocaleString(), "fb-wrong", false);
    setTimeout(advanceRound, 1100);
  } else {
    renderRound();
  }
}

function onOcc(){
  const guess = $("occInput").value.trim();
  if (!guess) return;

  triesOcc++;

  if (guess.toLowerCase() === person.occupation.toLowerCase()) {
    const points = LADDER_6[triesOcc - 1] || 0;
    setReveal("rOcc", person.occupation);
    updateScore(points);
    feedback("üéâ OCCUPATION CORRECT! +" + points, "fb-correct", false);
    setTimeout(advanceRound, 950);
    return;
  }

  const remaining = MAX_OCC_TRIES - triesOcc;
  if (remaining <= 0) {
    setReveal("rOcc", person.occupation);
    feedback("‚ùå FAIL ‚Äî OCCUPATION: " + person.occupation, "fb-wrong", false);
    setTimeout(advanceRound, 1100);
    return;
  }

  feedback("‚ùå WRONG ‚Äî " + remaining + " LEFT", "fb-wrong", true);
  renderRound();
}

function onState(){
  const pickState = $("stateSelect").value;
  triesState++;

  renderClues(); // clue count depends on triesState

  if (pickState === person.state) {
    setReveal("rState", person.state);
    const points = [10, 8, 6, 4, 2][triesState - 1] || 0;
    updateScore(points);
    feedback("üó∫Ô∏è STATE CORRECT! +" + points, "fb-correct", false);
    setTimeout(advanceRound, 950);
    return;
  }

  const remaining = MAX_STATE_TRIES - triesState;
  if (remaining <= 0) {
    setReveal("rState", person.state);
    feedback("‚ùå FAIL ‚Äî STATE WAS: " + person.state, "fb-wrong", false);
    setTimeout(advanceRound, 1100);
    return;
  }

  feedback("‚ùå WRONG STATE ‚Äî " + remaining + " LEFT (CLUE UNLOCKED)", "fb-wrong", true);
  renderRound();
}

// --------- Boot ---------
window.addEventListener("load", async () => {
  $("score").textContent = "0";
  feedback("LOADING FACES‚Ä¶", "", false);

  await loadFaceUrls();

  if (!FACE_URLS.length) {
    feedback("NO FACES YET ‚Äî GO TO /admin.html AND GENERATE", "fb-wrong", false);
  }

  startNewPerson();
});
